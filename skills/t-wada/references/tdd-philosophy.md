# t-wada TDD哲学リファレンス

## 核心原則

### Red → Green → Refactor

テスト駆動開発の基本サイクル:

1. **Red**: まず失敗するテストを書く。このテストはまだ存在しないコードの振る舞いを記述する。
2. **Green**: テストを通す最小限のコードを書く。美しさは求めない。まず動くこと。
3. **Refactor**: テストが通った状態を維持しながら、コードを整理する。

「テストが通っている」という安全ネットがあるからこそ、安心してリファクタリングできる。

### Baby Steps

一度にひとつのことだけを変える。変更が小さいほど:
- 何が壊れたか特定しやすい
- git bisect が効果的に機能する
- レビュアーが変更を理解しやすい

### テストは設計ツール

テストは「書き終わったコードを検証するもの」ではない。テストを先に書くことで:
- APIの使いやすさを利用者の視点から検証できる
- 不要な依存関係に気づける
- インターフェースが自然に疎結合になる

テストが書きにくいコードは、設計に問題がある兆候。

### power-assert: 失敗が語るアサーション

テストが失敗した時、失敗メッセージだけで原因がわかるべき。

```javascript
// Bad: 何が失敗したかわからない
assert.ok(result);

// Better: power-assert なら式の各部分の値が表示される
assert(response.body.users.length === 3);
// =>
// assert(response.body.users.length === 3)
//        |        |    |     |      |
//        |        |    |     2      false
//        |        |    [{...},{...}]
//        |        {users: [{...},{...}]}
//        {status: 200, body: {users: [...]}}
```

## 言語別推奨構成

### JavaScript / TypeScript

| カテゴリ | 推奨 | 理由 |
|---------|------|------|
| フレームワーク | Vitest（新規）, Jest（既存） | VitestはESM対応で高速。既存Jestは移行コストに見合わないことが多い |
| アサーション | power-assert または Vitest expect | power-assertは失敗時の情報量が圧倒的 |
| カバレッジ | v8（c8 / @vitest/coverage-v8） | IstanbulよりV8ネイティブカバレッジが高速 |
| モック | フレームワーク内蔵（vitest mock / jest mock） | 外部ライブラリ不要 |

### PHP

| カテゴリ | 推奨 | 理由 |
|---------|------|------|
| フレームワーク | PHPUnit | デファクトスタンダード。Pestはラッパーとして検討可 |
| カバレッジ | pcov | Xdebugより高速。CI環境では特に有効 |
| 静的解析 | PHPStan（Level 5以上） | テストと静的解析は補完関係 |
| モック | PHPUnit内蔵 / Mockery | 複雑なモックが必要な場合のみMockery |

### Python

| カテゴリ | 推奨 | 理由 |
|---------|------|------|
| フレームワーク | pytest | unittestより簡潔。fixtureの仕組みが強力 |
| カバレッジ | pytest-cov（coverage.py） | pytest統合が自然 |
| 型チェック | mypy / pyright | 動的型付け言語ではテスト+型チェックで安全性を確保 |
| モック | pytest-mock（unittest.mock wrapper） | pytestスタイルで記述可能 |

### Go

| カテゴリ | 推奨 | 理由 |
|---------|------|------|
| フレームワーク | go test（標準） | 外部フレームワーク不要。testifyは便利だが必須ではない |
| カバレッジ | go test -coverprofile | 標準ツールで十分 |
| リンター | golangci-lint | 複数リンターを統合実行 |

### Rust

| カテゴリ | 推奨 | 理由 |
|---------|------|------|
| フレームワーク | cargo test（標準） | 外部フレームワーク不要 |
| カバレッジ | cargo-tarpaulin | Rust向けカバレッジの定番 |
| リンター | clippy | 標準ツール |

## よくあるアンチパターン

1. **テストゼロで機能追加を続ける** — 技術的負債が指数関数的に増加する。まず1つテストを書くことから始める。
2. **CIでテストが実行されない** — テストが存在してもCIで実行されなければ形骸化する。
3. **カバレッジだけを追う** — 100%が目標ではない。重要なビジネスロジックのカバレッジを優先する。
4. **テストファイルが肥大化** — テスト自体もリファクタリング対象。ヘルパー関数やフィクスチャを共通化する。
5. **テスト実行が遅い** — 遅いテストは実行されなくなる。単体テストと統合テストを分離する。
